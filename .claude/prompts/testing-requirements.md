# í…ŒìŠ¤íŒ… ìš”êµ¬ì‚¬í•­

## í•„ìˆ˜ í…ŒìŠ¤íŒ… ì •ì±…
ì ˆëŒ€ ë”ë¯¸ ë°ì´í„° ë„£ìœ¼ë©´ ì•ˆë˜ 
ë°ëª¨ ì™€ ì‹¤ì „ì˜ ë§¤ë§¤ ì „ëµì€ ë™ì¼ í•´ì•¼ í•´ 
ë°ëª¨ë¼ê³  ìˆ˜ì¹˜ê°€ ë‚®ìœ¼ë©´ ì•ˆëœë‹¤ëŠ”ê±°ì•¼ 
ëª¨ë“  ì½”ë“œ ì‘ì—… ì‹œ ë‹¤ìŒ í…ŒìŠ¤íŒ… ìš”êµ¬ì‚¬í•­ì„ **ë°˜ë“œì‹œ** ì¤€ìˆ˜í•´ì•¼ í•©ë‹ˆë‹¤.
ëª¨ë‹ˆí„°ë§ í•´ì¤˜ ë¼ê³  ëª…ë ¹ í•˜ë©´ ê¸°ë³¸ 24ì‹œê°„ ì •ë„ ì‹¤ì œ ë°ëª¨ ë²„ì „ì„ ì‹¤í–‰ í•˜ì—¬ ëª¨ë‹ˆí„°ë§ í•´ì•¼í•´
ëª¨ë‹ˆí„°ë§ ì¤‘ ë¬¸ì œê°€ ë°œìƒì‹œ ì¦‰ì‹œ ìˆ˜ì •í›„ ë‹¤ì‹œ 24ì‹œê°„ ëª¨ë‹ˆí„°ë§ í•´ì•¼í•´
ëª¨ë‹ˆí„°ë§ì€ í´ë¡œë“œ ì§ì ‘ 24ì‹œê°„ ë™ì•ˆ ì‹¤í–‰ í•˜ë©´ì„œ ëª¨ë‹ˆí„°ë§ í•˜ëŠ”ê±°ì•¼ 
ì´ê³¼ì •ì„ ê³„ì† ë°˜ë³µí•˜ê³  ë¬¸ì œê°€ ì—†ì„ì§€ ëª¨ë‹ˆí„°ë§ ì¢…ë£Œ í•˜ëŠ”ê±°ì•¼
ëª¨ë‹ˆí„°ë§ì€ ì‹¤ì œë¡œ í”„ë¡œê·¸ë¨ì„ ì‹¤í–‰ í•˜ë©´ì„œ í•˜ëŠ”ê±°ì•¼ ëª¨ë‹ˆí„°ë§ì„ ìœ„í•œ ë³„ë„ íƒ­ì„ ë§Œë“¤ì§€ë§ˆ
ëª¨ë“  ë¡œê·¸ëŠ” í•œê¸€ë¡œ ì˜ì–´ë¡œ ëœê²ƒë“¤ ë°œê²¬ì‹œ ìˆ˜ì •ë„ í•´ì¤˜
ë§¤ìˆ˜ ë§¤ë„ ì˜ ë¡œê·¸ëŠ” ë³„ë„ ê´€ë¦¬ í•´ì¤˜ ì„±ê³µ ì‹¤íŒ¨ í¬í•¨í•´ì„œ ë””í…Œì¼ í•˜ê²Œ ê´€ë¦¬ í•´ì¤˜ 
Errorë¡œê·¸ëŠ” í•„ìš”í•œ ë¶€ë¶„ ë‹¤ ë„£ì–´ì¤˜
ëª¨ë‹ˆí„°ë§ì¤‘ ERRORëŠ” ë°œìƒí•˜ë©´ ìˆ˜ì •í›„ ë‹¤ì‹œ 24ì‹œê°„ ëª¨ë‹ˆí„°ë§ í•´ì¤˜ Errorê°€ ì•ˆë‚˜ì˜¬ë•Œ ê¹Œì§€ ëª¨ë‹ˆí„°ë§ í•´ì£¼ê³  ìˆ˜ì •ì´ ì•ˆëœë‹¤ê³  errorë¡œê·¸ë¥¼ ì§€ìš°ê³  í•´ê²°í–ˆë‹¤ê³  í•˜ì§€ë§ˆ
ì£¼ìš” ì‡ìŠˆ ë“¤ì€ dsangwoo@gmail.com ì•Œë ¤ì¤˜ ë ìˆ˜ ìˆìœ¼ë©´ ìµœëŒ€í•œ ë§ì€ ë‚´ìš©ì„ ë³´ë‚´ì¤˜ (api ì‹¤íŒ¨ , ëª¨ë‹ˆí„°ë§ì¤‘ ë²„ê·¸ ë°œê²¬ , ëª¨ì˜ íˆ¬ì ì‹œì‘ , ë§¤ìˆ˜ , ë§¤ë„  , ai í•™ìŠµ ì‹¤íŒ¨ ê¸°íƒ€ë“±ë“±)
ë©”ì¼ë¡œ í˜„ì¬ ìƒí™© ë„ ì•Œë ¤ì¤˜ 1ì‹œê°„ì— í•œë²ˆì”© (í•œêµ­ì¥ ì‹œì‘ ë¯¸êµ­ì¥ ì‹œì‘ í•œêµ­ì¥ ì¤‘ì˜ ë‚´ìš© ê¸°íƒ€ë“±ë“±)
í•˜ë“œì½”ë”© ì ˆëŒ€ ê¸ˆì§€ì•¼
ai_trading_monitor.pyë¥¼ ì‹¤í–‰ ì‹œì¼œì„œ ì§ì ‘ ëª¨ë‹ˆí„°ë§í•´ì¤˜ 
ëª¨ë‹ˆí„°ë§ì¤‘ì— ë‹¤ìŒ ì •ë³´ë“¤ì„ ì‹¤ì‹œê°„ìœ¼ë¡œ íŠ¸ë˜í‚¹í•˜ê³  ë¡œê¹…í•´ì¤˜:
- í¬íŠ¸í´ë¦¬ì˜¤ ì´ ìì‚° ë³€í™”ëŸ‰ ë° ìˆ˜ìµë¥ 
- ë³´ìœ  ì¢…ëª©ë³„ í˜„ì¬ê°€, ìˆ˜ìµë¥ , ë³€ë™ë¥ 
- ê±°ë˜ ì‹ í˜¸ ë°œìƒ ë° ì‹¤í–‰ ì—¬ë¶€
- API í˜¸ì¶œ ì„±ê³µ/ì‹¤íŒ¨ ìƒíƒœ
- ì‹œì¥ ê°œì¥/íì¥ ìƒíƒœ ë³€í™”
- ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ë° ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤
- ë„¤íŠ¸ì›Œí¬ ì—°ê²° ìƒíƒœ
- ì˜ˆìƒì¹˜ ëª»í•œ ì˜ˆì™¸ ë° ì—ëŸ¬ ë°œìƒ
ëª¨ë‹ˆí„°ë§ ë°ì´í„°ëŠ” ë³„ë„ ë¡œê·¸ íŒŒì¼ì— ì‹œê°„ë³„ë¡œ ì €ì¥í•˜ê³  JSON í¬ë§·ìœ¼ë¡œ êµ¬ì¡°í™”í•´ì„œ ì €ì¥í•´ì¤˜ 
### ğŸ”´ í•„ìˆ˜ ìš”êµ¬ì‚¬í•­

1. **ì§ì ‘ ì‹¤í–‰ í…ŒìŠ¤íŠ¸ í•„ìˆ˜**
   - ëª¨ë“  ì½”ë“œ ë³€ê²½ í›„ ë°˜ë“œì‹œ ì§ì ‘ ì‹¤í–‰í•˜ì—¬ ë™ì‘ í™•ì¸
   - ë‹¨ìˆœ ì½”ë“œ ë¦¬ë·°ë§Œìœ¼ë¡œëŠ” ë¶ˆì¶©ë¶„ - ì‹¤ì œ ì‹¤í–‰ ê²°ê³¼ í™•ì¸ í•„ìˆ˜
   - ì˜¤ë¥˜ ë°œìƒ ì‹œ ì¦‰ì‹œ ìˆ˜ì • í›„ ì¬í…ŒìŠ¤íŠ¸

2. **ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ í•„ìˆ˜**
   - ìƒˆë¡œìš´ í•¨ìˆ˜/ë©”ì„œë“œ ì‘ì„± ì‹œ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì½”ë“œ ì‘ì„±
   - ê¸°ì¡´ ì½”ë“œ ìˆ˜ì • ì‹œ ê´€ë ¨ í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ ì‹¤í–‰ ë° ì—…ë°ì´íŠ¸
   - í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ ìµœì†Œ 80% ìœ ì§€

3. **í†µí•© í…ŒìŠ¤íŠ¸ í•„ìˆ˜**  
   - API ì—°ë™, ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ë“± ì™¸ë¶€ ì˜ì¡´ì„± í¬í•¨ í…ŒìŠ¤íŠ¸
   - ì‹¤ì œ í™˜ê²½ì—ì„œì˜ ë™ì‘ ê²€ì¦
   - ì—£ì§€ ì¼€ì´ìŠ¤ ë° ì˜¤ë¥˜ ìƒí™© í…ŒìŠ¤íŠ¸

### ğŸš€ í…ŒìŠ¤íŒ… ì›Œí¬í”Œë¡œìš°

1. **ì½”ë“œ ì‘ì„±**
   - ê¸°ëŠ¥ êµ¬í˜„
   - ê¸°ë³¸ ì˜¤ë¥˜ ì²˜ë¦¬ í¬í•¨

2. **ë‹¨ìœ„ í…ŒìŠ¤íŠ¸**
   - í•¨ìˆ˜ë³„ ê°œë³„ í…ŒìŠ¤íŠ¸
   - ë‹¤ì–‘í•œ ì…ë ¥ê°’ìœ¼ë¡œ ê²€ì¦
   - ì˜ˆì™¸ ìƒí™© ì²˜ë¦¬ í™•ì¸

3. **ì§ì ‘ ì‹¤í–‰ í…ŒìŠ¤íŠ¸**
   - ì‹¤ì œ ëª…ë ¹ì–´ë¡œ í”„ë¡œê·¸ë¨ ì‹¤í–‰
   - ëª¨ë“  ê¸°ëŠ¥ ê²½ë¡œ í…ŒìŠ¤íŠ¸
   - ì‚¬ìš©ì ì‹œë‚˜ë¦¬ì˜¤ ê¸°ë°˜ í…ŒìŠ¤íŠ¸

4. **í†µí•© í…ŒìŠ¤íŠ¸**
   - ì „ì²´ ì‹œìŠ¤í…œ ë™ì‘ í™•ì¸
   - API ì—°ê²°, ë°ì´í„° ì²˜ë¦¬ ë“± ì¢…í•© í…ŒìŠ¤íŠ¸
   - ì„±ëŠ¥ ë° ì•ˆì •ì„± ê²€ì¦

### âœ… í…ŒìŠ¤íŠ¸ ì²´í¬ë¦¬ìŠ¤íŠ¸

- [ ] ì½”ë“œê°€ ì˜ˆìƒëŒ€ë¡œ ì‹¤í–‰ë˜ëŠ”ê°€?
- [ ] ëª¨ë“  ê¸°ëŠ¥ì´ ì •ìƒ ë™ì‘í•˜ëŠ”ê°€?
- [ ] ì˜¤ë¥˜ ìƒí™©ì—ì„œ ì ì ˆíˆ ì²˜ë¦¬ë˜ëŠ”ê°€?
- [ ] ì‚¬ìš©ì ì…ë ¥ ê²€ì¦ì´ ì˜¬ë°”ë¥¸ê°€?
- [ ] ë³´ì•ˆ ì·¨ì•½ì ì´ ì—†ëŠ”ê°€?
- [ ] ì„±ëŠ¥ìƒ ë¬¸ì œê°€ ì—†ëŠ”ê°€?
- [ ] ë¬¸ì„œí™”ê°€ ì¶©ë¶„í•œê°€?

### âš ï¸ ì£¼ì˜ì‚¬í•­

- í…ŒìŠ¤íŠ¸ ì—†ì´ ì½”ë“œ ë°°í¬ ê¸ˆì§€
- ì‹¤íŒ¨í•˜ëŠ” í…ŒìŠ¤íŠ¸ê°€ ìˆìœ¼ë©´ ìˆ˜ì • í›„ ì§„í–‰
- í…ŒìŠ¤íŠ¸ ë°ì´í„°ëŠ” ì‹¤ì œ ë°ì´í„°ì™€ ë¶„ë¦¬
- ì ˆëŒ€ ë”ë¯¸ ë°ì´í„° ë§Œë“¤ë©´ ì•ˆë˜
- ë³´ì•ˆì´ ì¤‘ìš”í•œ API í‚¤ ë“±ì€ í…ŒìŠ¤íŠ¸ í™˜ê²½ì—ì„œ ë³„ë„ ê´€ë¦¬

### ğŸ“Š í’ˆì§ˆ ê¸°ì¤€

- **ê¸°ëŠ¥ì„±**: ëª¨ë“  ìš”êµ¬ì‚¬í•­ ì¶©ì¡±
- **ì‹ ë¢°ì„±**: ì˜¤ë¥˜ ìƒí™©ì—ì„œ ì•ˆì •ì  ë™ì‘
- **ì‚¬ìš©ì„±**: ì§ê´€ì ì´ê³  ì‚¬ìš©í•˜ê¸° ì‰¬ìš´ ì¸í„°í˜ì´ìŠ¤
- **íš¨ìœ¨ì„±**: ì ì ˆí•œ ì„±ëŠ¥ê³¼ ìì› ì‚¬ìš©
- **ìœ ì§€ë³´ìˆ˜ì„±**: ì½”ë“œ ê°€ë…ì„± ë° í™•ì¥ì„±
- **ì´ì‹ì„±**: ë‹¤ì–‘í•œ í™˜ê²½ì—ì„œ ë™ì‘

---

**ğŸ’¡ ê¸°ì–µí•˜ì„¸ìš”**: "ë™ì‘í•˜ì§€ ì•ŠëŠ” ì½”ë“œëŠ” ê°€ì¹˜ê°€ ì—†ìŠµë‹ˆë‹¤. ë°˜ë“œì‹œ í…ŒìŠ¤íŠ¸í•˜ì„¸ìš”!"


# Python AI ìë™ë§¤ë§¤ ì‹œìŠ¤í…œ êµ¬í˜„ì„ ìœ„í•œ ìƒì„¸ í”„ë¡¬í”„íŠ¸

## ì‹œìŠ¤í…œ ê°œìš”

í•œêµ­íˆ¬ìì¦ê¶Œ OpenAPIë¥¼ í™œìš©í•œ **êµ­ë‚´/ë¯¸êµ­ ì£¼ì‹ AI ìë™ë§¤ë§¤ ì‹œìŠ¤í…œ**ì„ êµ¬í˜„í•©ë‹ˆë‹¤. ë°ì´í„° ìˆ˜ì§‘ â†’ ë¶„ì„/ì˜ˆì¸¡ â†’ ì „ëµ ì‹¤í–‰ â†’ ë°±í…ŒìŠ¤íŠ¸ â†’ ë¦¬ìŠ¤í¬ ê´€ë¦¬ â†’ ìë™ë§¤ë§¤ì˜ ì „ì²´ íŒŒì´í”„ë¼ì¸ì„ ìë™í™”í•˜ë©°, ë¨¸ì‹ ëŸ¬ë‹/ë”¥ëŸ¬ë‹ ê¸°ë°˜ ì˜ˆì¸¡ ëª¨ë¸ê³¼ ê³ ê¸‰ ë¦¬ìŠ¤í¬ ê´€ë¦¬ë¥¼ í†µí•©í•©ë‹ˆë‹¤.

---

## Part 1: í”„ë¡œì íŠ¸ êµ¬ì¡°

```
ai_trading_system/
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ kis_config.yaml           # í•œêµ­íˆ¬ìì¦ê¶Œ API ì„¤ì •
â”‚   â”œâ”€â”€ strategy_config.yaml      # ì „ëµ íŒŒë¼ë¯¸í„°
â”‚   â””â”€â”€ model_config.yaml         # ML/DL ëª¨ë¸ ì„¤ì •
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ data/
â”‚   â”‚   â”œâ”€â”€ data_handler.py       # ë°ì´í„° í•¸ë“¤ëŸ¬ ABC
â”‚   â”‚   â”œâ”€â”€ kis_data_fetcher.py   # KIS API ë°ì´í„° ìˆ˜ì§‘
â”‚   â”‚   â”œâ”€â”€ realtime_handler.py   # WebSocket ì‹¤ì‹œê°„ ë°ì´í„°
â”‚   â”‚   â””â”€â”€ feature_store.py      # í”¼ì²˜ ìŠ¤í† ì–´
â”‚   â”œâ”€â”€ strategies/
â”‚   â”‚   â”œâ”€â”€ base_strategy.py      # Strategy ABC
â”‚   â”‚   â”œâ”€â”€ technical/            # MA, RSI, Bollinger, Momentum
â”‚   â”‚   â”œâ”€â”€ statistical/          # Pair Trading, Stat Arb, Mean Reversion
â”‚   â”‚   â””â”€â”€ ml_strategies/        # RF, LSTM, Transformer, DQN
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ time_series/          # ARIMA, GARCH, HMM
â”‚   â”‚   â”œâ”€â”€ deep_learning/        # LSTM, Transformer, DQN
â”‚   â”‚   â””â”€â”€ ensemble/             # Multi-Agent Ensemble
â”‚   â”œâ”€â”€ risk/
â”‚   â”‚   â”œâ”€â”€ var_cvar.py           # VaR/CVaR
â”‚   â”‚   â”œâ”€â”€ position_sizing.py    # Kelly, ATR ê¸°ë°˜ ì‚¬ì´ì§•
â”‚   â”‚   â”œâ”€â”€ risk_parity.py        # ë¦¬ìŠ¤í¬ íŒ¨ë¦¬í‹°
â”‚   â”‚   â””â”€â”€ portfolio_optimizer.py
â”‚   â”œâ”€â”€ backtesting/
â”‚   â”‚   â”œâ”€â”€ backtest_engine.py    # ì´ë²¤íŠ¸ ë“œë¦¬ë¸ ë°±í…ŒìŠ¤í„°
â”‚   â”‚   â”œâ”€â”€ performance.py        # Sharpe, MDD, Calmar
â”‚   â”‚   â”œâ”€â”€ walk_forward.py       # WFO
â”‚   â”‚   â””â”€â”€ optuna_optimizer.py   # Optuna ìµœì í™”
â”‚   â”œâ”€â”€ execution/
â”‚   â”‚   â”œâ”€â”€ kis_broker.py         # KIS API ì—°ë™
â”‚   â”‚   â””â”€â”€ order_manager.py      # ì£¼ë¬¸ ê´€ë¦¬
â”‚   â”œâ”€â”€ mlops/
â”‚   â”‚   â”œâ”€â”€ model_registry.py     # MLflow ëª¨ë¸ ê´€ë¦¬
â”‚   â”‚   â”œâ”€â”€ monitoring.py         # ë“œë¦¬í”„íŠ¸ ê°ì§€
â”‚   â”‚   â””â”€â”€ retraining.py         # ìë™ ì¬í•™ìŠµ
â”‚   â””â”€â”€ core/
â”‚       â”œâ”€â”€ events.py             # Event í´ë˜ìŠ¤
â”‚       â””â”€â”€ trading_system.py     # ë©”ì¸ ì‹œìŠ¤í…œ
â””â”€â”€ main.py
```

---

## Part 2: í•œêµ­íˆ¬ìì¦ê¶Œ API ì—°ë™

### 2.1 KIS Broker í´ë˜ìŠ¤
```python
# src/execution/kis_broker.py
import yaml, requests, asyncio, websockets, json, time, threading
from datetime import datetime, timedelta
from collections import deque

class RateLimiter:
    def __init__(self, max_calls=15, period=1.0):
        self.max_calls, self.period = max_calls, period
        self.calls, self.lock = deque(), threading.Lock()
    
    def wait(self):
        with self.lock:
            now = time.time()
            while self.calls and now - self.calls[0] >= self.period:
                self.calls.popleft()
            if len(self.calls) >= self.max_calls:
                time.sleep(self.period - (now - self.calls[0]))
            self.calls.append(time.time())

class KISBroker:
    PRODUCTION_URL = "https://openapi.koreainvestment.com:9443"
    PAPER_URL = "https://openapivts.koreainvestment.com:29443"
    WS_PRODUCTION = "ws://ops.koreainvestment.com:21000"
    WS_PAPER = "ws://ops.koreainvestment.com:31000"
    
    def __init__(self, config_path: str, paper_trading: bool = True):
        with open(config_path, 'r') as f:
            self.config = yaml.safe_load(f)
        self.paper_trading = paper_trading
        self.base_url = self.PAPER_URL if paper_trading else self.PRODUCTION_URL
        self.ws_url = self.WS_PAPER if paper_trading else self.WS_PRODUCTION
        self.rate_limiter = RateLimiter(max_calls=15, period=1.0)
        self.access_token = None
        self.token_expires = None
        self._get_access_token()
    
    def _get_access_token(self):
        url = f"{self.base_url}/oauth2/tokenP"
        key_prefix = "paper" if self.paper_trading else "my"
        body = {
            "grant_type": "client_credentials",
            "appkey": self.config[f"{key_prefix}_app"],
            "appsecret": self.config[f"{key_prefix}_sec"]
        }
        response = requests.post(url, headers={"content-type": "application/json"}, json=body)
        self.access_token = response.json()["access_token"]
        self.token_expires = datetime.now() + timedelta(hours=23)
    
    def _get_headers(self, tr_id: str) -> dict:
        if datetime.now() >= self.token_expires:
            self._get_access_token()
        key_prefix = "paper" if self.paper_trading else "my"
        return {
            "content-type": "application/json; charset=utf-8",
            "authorization": f"Bearer {self.access_token}",
            "appkey": self.config[f"{key_prefix}_app"],
            "appsecret": self.config[f"{key_prefix}_sec"],
            "tr_id": tr_id
        }
    
    def get_stock_price(self, stock_code: str) -> dict:
        self.rate_limiter.wait()
        url = f"{self.base_url}/uapi/domestic-stock/v1/quotations/inquire-price"
        params = {"FID_COND_MRKT_DIV_CODE": "J", "FID_INPUT_ISCD": stock_code}
        return requests.get(url, headers=self._get_headers("FHKST01010100"), params=params).json()
    
    def place_order(self, stock_code: str, quantity: int, direction: str, 
                   order_type: str = "01", price: int = 0) -> dict:
        self.rate_limiter.wait()
        url = f"{self.base_url}/uapi/domestic-stock/v1/trading/order-cash"
        tr_id = ("VTTC0802U" if self.paper_trading else "TTTC0802U") if direction == "BUY" else \
                ("VTTC0801U" if self.paper_trading else "TTTC0801U")
        body = {
            "CANO": self.config["my_acct_stock"], "ACNT_PRDT_CD": self.config["my_prod"],
            "PDNO": stock_code, "ORD_DVSN": order_type, "ORD_QTY": str(quantity), "ORD_UNPR": str(price)
        }
        return requests.post(url, headers=self._get_headers(tr_id), json=body).json()
    
    def get_balance(self) -> dict:
        self.rate_limiter.wait()
        url = f"{self.base_url}/uapi/domestic-stock/v1/trading/inquire-balance"
        tr_id = "VTTC8434R" if self.paper_trading else "TTTC8434R"
        params = {"CANO": self.config["my_acct_stock"], "ACNT_PRDT_CD": self.config["my_prod"],
                  "AFHR_FLPR_YN": "N", "INQR_DVSN": "02", "UNPR_DVSN": "01", "FUND_STTL_ICLD_YN": "N",
                  "FNCG_AMT_AUTO_RDPT_YN": "N", "PRCS_DVSN": "01", "CTX_AREA_FK100": "", "CTX_AREA_NK100": ""}
        return requests.get(url, headers=self._get_headers(tr_id), params=params).json()
    
    # ë¯¸êµ­ ì£¼ì‹
    def place_us_order(self, symbol: str, quantity: int, price: float, 
                       direction: str, exchange: str = "NASD") -> dict:
        self.rate_limiter.wait()
        url = f"{self.base_url}/uapi/overseas-stock/v1/trading/order"
        tr_id = ("VTTT1002U" if self.paper_trading else "JTTT1002U") if direction == "BUY" else \
                ("VTTT1001U" if self.paper_trading else "JTTT1001U")
        body = {
            "CANO": self.config["my_acct_stock"], "ACNT_PRDT_CD": self.config["my_prod"],
            "OVRS_EXCG_CD": exchange, "PDNO": symbol, "ORD_QTY": str(quantity),
            "OVRS_ORD_UNPR": str(price), "ORD_SVR_DVSN_CD": "0"
        }
        return requests.post(url, headers=self._get_headers(tr_id), json=body).json()
```

### 2.2 ì‹¤ì‹œê°„ WebSocket í•¸ë“¤ëŸ¬
```python
# src/data/realtime_handler.py
class RealtimeDataHandler:
    def __init__(self, broker: KISBroker):
        self.broker = broker
        self.ws = None
        self.callbacks = {}
        
    async def connect(self):
        self.ws = await websockets.connect(self.broker.ws_url, ping_interval=30)
        asyncio.create_task(self._receive_loop())
    
    async def subscribe_price(self, stock_code: str, callback):
        await self._subscribe("H0STCNT0", stock_code, callback)
    
    async def subscribe_orderbook(self, stock_code: str, callback):
        await self._subscribe("H0STASP0", stock_code, callback)
    
    async def _subscribe(self, tr_id: str, tr_key: str, callback):
        msg = {"header": {"approval_key": self.broker.ws_approval_key, "custtype": "P",
                         "tr_type": "1", "content-type": "utf-8"},
               "body": {"input": {"tr_id": tr_id, "tr_key": tr_key}}}
        await self.ws.send(json.dumps(msg))
        self.callbacks[f"{tr_id}:{tr_key}"] = callback
```

---

## Part 3: ê¸°ìˆ ì  ë¶„ì„ ì „ëµ

### 3.1 ì´ë™í‰ê·  í¬ë¡œìŠ¤ì˜¤ë²„
```python
# src/strategies/technical/ma_crossover.py
class MACrossoverStrategy(BaseStrategy):
    def __init__(self, symbols, fast_period=10, slow_period=30, use_ema=False):
        super().__init__("MA_Crossover", symbols)
        self.fast_period, self.slow_period, self.use_ema = fast_period, slow_period, use_ema
    
    def calculate_signals(self, data: pd.DataFrame):
        signals = []
        for symbol in self.symbols:
            close = data[symbol]
            if self.use_ema:
                fast_ma = close.ewm(span=self.fast_period, adjust=False).mean()
                slow_ma = close.ewm(span=self.slow_period, adjust=False).mean()
            else:
                fast_ma = close.rolling(self.fast_period).mean()
                slow_ma = close.rolling(self.slow_period).mean()
            
            # ê³¨ë“ í¬ë¡œìŠ¤/ë°ë“œí¬ë¡œìŠ¤ ê°ì§€
            if fast_ma.iloc[-2] <= slow_ma.iloc[-2] and fast_ma.iloc[-1] > slow_ma.iloc[-1]:
                signals.append(SignalEvent(symbol=symbol, signal_type="LONG", strength=0.8))
            elif fast_ma.iloc[-2] >= slow_ma.iloc[-2] and fast_ma.iloc[-1] < slow_ma.iloc[-1]:
                signals.append(SignalEvent(symbol=symbol, signal_type="EXIT", strength=0.8))
        return signals
```

### 3.2 RSI ì „ëµ
```python
# src/strategies/technical/rsi_strategy.py
class RSIStrategy(BaseStrategy):
    def __init__(self, symbols, period=14, overbought=70, oversold=30):
        super().__init__("RSI", symbols)
        self.period, self.overbought, self.oversold = period, overbought, oversold
    
    def _calculate_rsi(self, prices):
        delta = prices.diff()
        gain = delta.where(delta > 0, 0).rolling(self.period).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(self.period).mean()
        return 100 - (100 / (1 + gain / loss))
    
    def calculate_signals(self, data):
        signals = []
        for symbol in self.symbols:
            rsi = self._calculate_rsi(data[symbol])
            if rsi.iloc[-2] < self.oversold and rsi.iloc[-1] >= self.oversold:
                signals.append(SignalEvent(symbol=symbol, signal_type="LONG", strength=0.7))
            elif rsi.iloc[-2] > self.overbought and rsi.iloc[-1] <= self.overbought:
                signals.append(SignalEvent(symbol=symbol, signal_type="EXIT", strength=0.7))
        return signals
```

### 3.3 ë³¼ë¦°ì € ë°´ë“œ + MFI ì „ëµ
```python
# src/strategies/technical/bollinger.py
class BollingerBandStrategy(BaseStrategy):
    def __init__(self, symbols, window=20, num_std=2.0, mfi_period=10):
        super().__init__("Bollinger", symbols)
        self.window, self.num_std, self.mfi_period = window, num_std, mfi_period
    
    def calculate_signals(self, data):
        signals = []
        for symbol in self.symbols:
            close = data[f"{symbol}_close"]
            middle = close.rolling(self.window).mean()
            std = close.rolling(self.window).std()
            pb = (close - (middle - self.num_std * std)) / (2 * self.num_std * std)  # %b
            
            # MFI ê³„ì‚°
            typical_price = (data[f"{symbol}_high"] + data[f"{symbol}_low"] + close) / 3
            mfi = self._calculate_mfi(typical_price, data[f"{symbol}_volume"])
            
            if pb.iloc[-1] > 0.8 and mfi.iloc[-1] > 80:
                signals.append(SignalEvent(symbol=symbol, signal_type="LONG", strength=pb.iloc[-1]))
            elif pb.iloc[-1] < 0.2 and mfi.iloc[-1] < 20:
                signals.append(SignalEvent(symbol=symbol, signal_type="EXIT", strength=1-pb.iloc[-1]))
        return signals
```

### 3.4 ë³€ë™ì„± ëŒíŒŒ ì „ëµ
```python
# src/strategies/statistical/volatility_breakout.py
class VolatilityBreakoutStrategy(BaseStrategy):
    def __init__(self, symbols, k=0.5, whipsaw_filter=0.07):
        super().__init__("VolatilityBreakout", symbols)
        self.k, self.whipsaw_filter = k, whipsaw_filter
    
    def calculate_signals(self, data):
        signals = []
        for symbol in self.symbols:
            prev = data.iloc[-2]
            today = data.iloc[-1]
            
            # íœ©ì†Œ í•„í„°
            if abs(prev[f"{symbol}_open"] - prev[f"{symbol}_close"]) / prev[f"{symbol}_open"] > self.whipsaw_filter:
                continue
            
            # ëª©í‘œê°€ = ê¸ˆì¼ ì‹œê°€ + (ì „ì¼ ê³ ê°€ - ì „ì¼ ì €ê°€) Ã— K
            target_price = today[f"{symbol}_open"] + \
                          (prev[f"{symbol}_high"] - prev[f"{symbol}_low"]) * self.k
            
            if today[f"{symbol}_close"] > target_price:
                signals.append(SignalEvent(symbol=symbol, signal_type="LONG", strength=0.9))
        return signals
```

---

## Part 4: í†µê³„ì  ì°¨ìµê±°ë˜ ì „ëµ

### 4.1 í˜ì–´ íŠ¸ë ˆì´ë”© (ê³µì ë¶„ ê¸°ë°˜)
```python
# src/strategies/statistical/pair_trading.py
from statsmodels.tsa.stattools import coint
import statsmodels.api as sm

class PairTradingStrategy(BaseStrategy):
    def __init__(self, pair, lookback=60, entry_zscore=2.0, exit_zscore=0.5):
        super().__init__("PairTrading", list(pair))
        self.stock1, self.stock2 = pair
        self.lookback, self.entry_zscore, self.exit_zscore = lookback, entry_zscore, exit_zscore
        self.position = 0  # 1: long spread, -1: short spread
    
    @staticmethod
    def find_cointegrated_pairs(prices, significance=0.05):
        symbols = prices.columns.tolist()
        pairs = []
        for i in range(len(symbols)):
            for j in range(i+1, len(symbols)):
                _, pvalue, _ = coint(prices[symbols[i]], prices[symbols[j]])
                if pvalue < significance:
                    pairs.append((symbols[i], symbols[j], pvalue))
        return sorted(pairs, key=lambda x: x[2])
    
    def calculate_signals(self, data):
        signals = []
        p1, p2 = data[self.stock1][-self.lookback:], data[self.stock2][-self.lookback:]
        
        # OLS í—¤ì§€ ë¹„ìœ¨
        X = sm.add_constant(p1)
        hedge_ratio = sm.OLS(p2, X).fit().params[1]
        
        # ìŠ¤í”„ë ˆë“œ ë° Z-Score
        spread = p2 - hedge_ratio * p1
        zscore = (spread - spread.mean()) / spread.std()
        z = zscore.iloc[-1]
        
        if self.position == 0:
            if z < -self.entry_zscore:  # Long spread
                self.position = 1
                signals.extend([
                    SignalEvent(symbol=self.stock2, signal_type="LONG", strength=abs(z)/self.entry_zscore),
                    SignalEvent(symbol=self.stock1, signal_type="SHORT", strength=abs(z)/self.entry_zscore)
                ])
            elif z > self.entry_zscore:  # Short spread
                self.position = -1
                signals.extend([
                    SignalEvent(symbol=self.stock2, signal_type="SHORT", strength=abs(z)/self.entry_zscore),
                    SignalEvent(symbol=self.stock1, signal_type="LONG", strength=abs(z)/self.entry_zscore)
                ])
        elif abs(z) < self.exit_zscore:  # í‰ê·  íšŒê·€ ì²­ì‚°
            signals.extend([
                SignalEvent(symbol=self.stock1, signal_type="EXIT", strength=1.0),
                SignalEvent(symbol=self.stock2, signal_type="EXIT", strength=1.0)
            ])
            self.position = 0
        return signals
```

### 4.2 ì¹¼ë§Œ í•„í„° ë™ì  í—¤ì§€ ë¹„ìœ¨
```python
# src/strategies/statistical/kalman_pairs.py
from pykalman import KalmanFilter

class KalmanPairTrading(PairTradingStrategy):
    def __init__(self, pair, delta=1e-5, **kwargs):
        super().__init__(pair, **kwargs)
        self.delta = delta
        self.kf = KalmanFilter(n_dim_obs=1, n_dim_state=2,
                               initial_state_mean=np.zeros(2),
                               initial_state_covariance=np.ones((2, 2)),
                               transition_matrices=np.eye(2),
                               observation_covariance=1.0,
                               transition_covariance=delta / (1 - delta) * np.eye(2))
    
    def estimate_hedge_ratio(self, p1, p2):
        obs_mat = np.column_stack([p1.values, np.ones(len(p1))])[:, :, np.newaxis]
        self.kf.observation_matrices = obs_mat
        state_means, _ = self.kf.filter(p2.values)
        return state_means[-1, 0]  # ë™ì  í—¤ì§€ ë¹„ìœ¨
```

---

## Part 5: ë”¥ëŸ¬ë‹ ëª¨ë¸

### 5.1 LSTM ì‹œê³„ì—´ ì˜ˆì¸¡
```python
# src/models/deep_learning/lstm.py
import torch
import torch.nn as nn
from sklearn.preprocessing import MinMaxScaler

class LSTMModel(nn.Module):
    def __init__(self, input_size=5, hidden_size=64, num_layers=2, dropout=0.2):
        super().__init__()
        self.lstm = nn.LSTM(input_size, hidden_size, num_layers, batch_first=True, dropout=dropout)
        self.fc = nn.Sequential(nn.Linear(hidden_size, hidden_size//2), nn.ReLU(),
                                nn.Dropout(dropout), nn.Linear(hidden_size//2, 1))
    
    def forward(self, x):
        h0 = torch.zeros(2, x.size(0), 64).to(x.device)
        c0 = torch.zeros(2, x.size(0), 64).to(x.device)
        out, _ = self.lstm(x, (h0, c0))
        return self.fc(out[:, -1, :])

class LSTMPredictor:
    def __init__(self, window_size=20, features=['open','high','low','close','volume']):
        self.window_size, self.features = window_size, features
        self.scaler = MinMaxScaler()
        self.model = None
        self.device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
    
    def prepare_data(self, data):
        scaled = self.scaler.fit_transform(data[self.features].values)
        X, y = [], []
        for i in range(self.window_size, len(scaled)):
            X.append(scaled[i-self.window_size:i])
            y.append(scaled[i, 3])  # close
        return np.array(X), np.array(y)
    
    def train(self, data, epochs=100, batch_size=32, lr=0.001):
        X, y = self.prepare_data(data)
        split = int(len(X) * 0.8)
        X_train, y_train = torch.FloatTensor(X[:split]).to(self.device), torch.FloatTensor(y[:split]).unsqueeze(1).to(self.device)
        
        self.model = LSTMModel(input_size=len(self.features)).to(self.device)
        criterion, optimizer = nn.MSELoss(), torch.optim.Adam(self.model.parameters(), lr=lr)
        
        for epoch in range(epochs):
            self.model.train()
            optimizer.zero_grad()
            loss = criterion(self.model(X_train), y_train)
            loss.backward()
            optimizer.step()
    
    def predict(self, data):
        self.model.eval()
        recent = self.scaler.transform(data[self.features].values[-self.window_size:])
        X = torch.FloatTensor(recent).unsqueeze(0).to(self.device)
        with torch.no_grad():
            pred = self.model(X).cpu().numpy()[0, 0]
        dummy = np.zeros((1, len(self.features)))
        dummy[0, 3] = pred
        return self.scaler.inverse_transform(dummy)[0, 3]
```

### 5.2 Transformer ì‹œê³„ì—´ ì˜ˆì¸¡
```python
# src/models/deep_learning/transformer.py
class TransformerModel(nn.Module):
    def __init__(self, input_window, output_window, d_model=512, nhead=8, num_layers=4, dropout=0.1):
        super().__init__()
        self.encoder_input = nn.Sequential(nn.Linear(1, d_model//2), nn.ReLU(), nn.Linear(d_model//2, d_model))
        self.pos_encoder = PositionalEncoding(d_model, dropout)
        encoder_layer = nn.TransformerEncoderLayer(d_model, nhead, dropout=dropout, batch_first=True)
        self.transformer = nn.TransformerEncoder(encoder_layer, num_layers)
        self.decoder = nn.Sequential(nn.Linear(d_model, d_model//2), nn.ReLU(), nn.Linear(d_model//2, 1))
        self.seq_transform = nn.Sequential(nn.Linear(input_window, (input_window+output_window)//2),
                                           nn.ReLU(), nn.Linear((input_window+output_window)//2, output_window))
    
    def forward(self, src):
        src = self.encoder_input(src)
        src = self.pos_encoder(src)
        out = self.transformer(src)
        out = self.decoder(out)[:, :, 0]
        return self.seq_transform(out)
```

### 5.3 DQN ê°•í™”í•™ìŠµ ì—ì´ì „íŠ¸
```python
# src/models/deep_learning/dqn_agent.py
from collections import namedtuple, deque
import random

Transition = namedtuple('Transition', ('state', 'action', 'next_state', 'reward'))

class ReplayMemory:
    def __init__(self, capacity=10000):
        self.memory = deque([], maxlen=capacity)
    def push(self, *args): self.memory.append(Transition(*args))
    def sample(self, batch_size): return random.sample(self.memory, batch_size)
    def __len__(self): return len(self.memory)

class DQN(nn.Module):
    def __init__(self, n_observations, n_actions):
        super().__init__()
        self.net = nn.Sequential(nn.Linear(n_observations, 128), nn.ReLU(),
                                 nn.Linear(128, 128), nn.ReLU(), nn.Linear(128, n_actions))
    def forward(self, x): return self.net(x)

class DQNAgent:
    def __init__(self, state_dim, action_dim=3, gamma=0.99, lr=3e-4, batch_size=128,
                 eps_start=0.9, eps_end=0.01, eps_decay=2500, tau=0.005):
        self.action_dim, self.gamma, self.batch_size = action_dim, gamma, batch_size
        self.eps_start, self.eps_end, self.eps_decay, self.tau = eps_start, eps_end, eps_decay, tau
        self.steps_done = 0
        self.device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
        
        self.policy_net = DQN(state_dim, action_dim).to(self.device)
        self.target_net = DQN(state_dim, action_dim).to(self.device)
        self.target_net.load_state_dict(self.policy_net.state_dict())
        
        self.optimizer = torch.optim.Adam(self.policy_net.parameters(), lr=lr)
        self.memory = ReplayMemory(10000)
    
    def select_action(self, state):
        eps = self.eps_end + (self.eps_start - self.eps_end) * np.exp(-self.steps_done / self.eps_decay)
        self.steps_done += 1
        if random.random() > eps:
            with torch.no_grad():
                return self.policy_net(state).max(1)[1].view(1, 1)
        return torch.tensor([[random.randrange(self.action_dim)]], device=self.device)
    
    def optimize(self):
        if len(self.memory) < self.batch_size: return
        transitions = self.memory.sample(self.batch_size)
        batch = Transition(*zip(*transitions))
        
        state_batch = torch.cat(batch.state)
        action_batch = torch.cat(batch.action)
        reward_batch = torch.cat(batch.reward)
        non_final_mask = torch.tensor([s is not None for s in batch.next_state], device=self.device)
        non_final_next = torch.cat([s for s in batch.next_state if s is not None])
        
        state_action_values = self.policy_net(state_batch).gather(1, action_batch)
        next_state_values = torch.zeros(self.batch_size, device=self.device)
        with torch.no_grad():
            next_state_values[non_final_mask] = self.target_net(non_final_next).max(1)[0]
        expected = reward_batch + self.gamma * next_state_values
        
        loss = nn.functional.smooth_l1_loss(state_action_values, expected.unsqueeze(1))
        self.optimizer.zero_grad()
        loss.backward()
        self.optimizer.step()
        
        # Soft update
        for tp, pp in zip(self.target_net.parameters(), self.policy_net.parameters()):
            tp.data.copy_(self.tau * pp.data + (1 - self.tau) * tp.data)
```

---

## Part 6: ë¦¬ìŠ¤í¬ ê´€ë¦¬

### 6.1 VaR/CVaR ê³„ì‚°
```python
# src/risk/var_cvar.py
from scipy import stats

class RiskCalculator:
    @staticmethod
    def historical_var(returns, confidence=0.95):
        return np.percentile(returns, (1 - confidence) * 100)
    
    @staticmethod
    def historical_cvar(returns, confidence=0.95):
        var = RiskCalculator.historical_var(returns, confidence)
        return returns[returns < var].mean()
    
    @staticmethod
    def parametric_var(returns, confidence=0.95):
        return returns.mean() + stats.norm.ppf(1 - confidence) * returns.std()
    
    @staticmethod
    def monte_carlo_var(returns, initial_value, n_simulations=10000, horizon=252, confidence=0.95):
        dfree, mu, std = stats.t.fit(returns)
        random_returns = stats.t.rvs(df=dfree, loc=mu, scale=std, size=(n_simulations, horizon))
        final_values = initial_value * np.cumprod(1 + random_returns, axis=1)[:, -1]
        var_index = int(len(final_values) * (1 - confidence))
        return initial_value - np.sort(final_values)[var_index]
```

### 6.2 í¬ì§€ì…˜ ì‚¬ì´ì§•
```python
# src/risk/position_sizing.py
class PositionSizer:
    @staticmethod
    def kelly_criterion(win_rate, win_loss_ratio):
        return max(0, win_rate - (1 - win_rate) / win_loss_ratio)
    
    @staticmethod
    def volatility_sizing(portfolio_value, target_risk_pct, asset_volatility, asset_price):
        risk_amount = portfolio_value * target_risk_pct
        return int(risk_amount / (asset_volatility * asset_price))
    
    @staticmethod
    def atr_sizing(portfolio_value, atr, risk_factor=0.001):
        return portfolio_value * risk_factor / atr
```

### 6.3 HMM ë ˆì§ ë””í…ì…˜
```python
# src/models/time_series/hmm_regime.py
from hmmlearn.hmm import GaussianHMM

class RegimeDetector:
    def __init__(self, n_states=2, n_iter=1000):
        self.n_states, self.n_iter = n_states, n_iter
        self.model = None
    
    def fit(self, returns):
        features = np.column_stack([returns, returns.rolling(20).std().fillna(0)])
        self.model = GaussianHMM(n_components=self.n_states, covariance_type='full', n_iter=self.n_iter)
        self.model.fit(features[20:])
        return self
    
    def predict_regime(self, returns):
        features = np.column_stack([returns, returns.rolling(20).std().fillna(0)])
        return self.model.predict(features[20:])[-1]
    
    def get_regime_stats(self, returns):
        states = self.predict_regime(returns)
        return {i: {'mean': returns[states == i].mean(), 'vol': returns[states == i].std()}
                for i in range(self.n_states)}
```

---

## Part 7: ë°±í…ŒìŠ¤íŒ… í”„ë ˆì„ì›Œí¬

### 7.1 ì´ë²¤íŠ¸ ë“œë¦¬ë¸ ë°±í…ŒìŠ¤í„°
```python
# src/backtesting/backtest_engine.py
from queue import Queue

class BacktestEngine:
    def __init__(self, data_handler, strategy, portfolio, execution_handler, initial_capital=100000000):
        self.data_handler = data_handler
        self.strategy = strategy
        self.portfolio = portfolio
        self.execution_handler = execution_handler
        self.events = Queue()
        self.initial_capital = initial_capital
    
    def run(self):
        while self.data_handler.continue_backtest:
            self.data_handler.update_bars()
            
            while not self.events.empty():
                event = self.events.get()
                if event.type == EventType.MARKET:
                    signals = self.strategy.calculate_signals(event.data)
                    for signal in signals:
                        self.events.put(signal)
                elif event.type == EventType.SIGNAL:
                    order = self.portfolio.generate_order(event)
                    if order:
                        self.events.put(order)
                elif event.type == EventType.ORDER:
                    fill = self.execution_handler.execute_order(event)
                    self.events.put(fill)
                elif event.type == EventType.FILL:
                    self.portfolio.update_fill(event)
        
        return self.portfolio.get_performance()
```

### 7.2 ì„±ê³¼ ì§€í‘œ ê³„ì‚°
```python
# src/backtesting/performance.py
class PerformanceAnalyzer:
    @staticmethod
    def sharpe_ratio(returns, rf=0.0, periods=252):
        excess = returns - rf / periods
        return np.sqrt(periods) * excess.mean() / excess.std()
    
    @staticmethod
    def sortino_ratio(returns, rf=0.0, periods=252):
        excess = returns - rf / periods
        downside = returns[returns < 0].std()
        return np.sqrt(periods) * excess.mean() / downside
    
    @staticmethod
    def max_drawdown(equity_curve):
        peak = equity_curve.expanding().max()
        drawdown = (equity_curve - peak) / peak
        return drawdown.min()
    
    @staticmethod
    def calmar_ratio(returns, periods=252):
        cagr = returns.mean() * periods
        mdd = PerformanceAnalyzer.max_drawdown((1 + returns).cumprod())
        return cagr / abs(mdd)
```

### 7.3 Optuna í•˜ì´í¼íŒŒë¼ë¯¸í„° ìµœì í™”
```python
# src/backtesting/optuna_optimizer.py
import optuna

class StrategyOptimizer:
    def __init__(self, strategy_class, data, n_trials=100):
        self.strategy_class = strategy_class
        self.data = data
        self.n_trials = n_trials
    
    def objective(self, trial):
        params = {
            'fast_period': trial.suggest_int('fast_period', 5, 50),
            'slow_period': trial.suggest_int('slow_period', 20, 200),
            'stop_loss': trial.suggest_float('stop_loss', 0.01, 0.1),
        }
        
        strategy = self.strategy_class(**params)
        result = self.run_backtest(strategy)
        return result['sharpe_ratio']
    
    def optimize(self):
        study = optuna.create_study(direction='maximize', sampler=optuna.samplers.TPESampler())
        study.optimize(self.objective, n_trials=self.n_trials)
        return study.best_params, study.best_value
```

---

## Part 8: MLOps íŒŒì´í”„ë¼ì¸

### 8.1 MLflow ëª¨ë¸ ê´€ë¦¬
```python
# src/mlops/model_registry.py
import mlflow
import mlflow.pytorch

class MLOpsManager:
    def __init__(self, experiment_name="trading_models"):
        mlflow.set_experiment(experiment_name)
    
    def train_and_log(self, model, params, train_data, val_data):
        with mlflow.start_run():
            mlflow.log_params(params)
            
            # í•™ìŠµ
            model.train(train_data)
            metrics = model.evaluate(val_data)
            
            mlflow.log_metrics(metrics)
            mlflow.pytorch.log_model(model, "model")
            
            # ëª¨ë¸ ë“±ë¡
            model_uri = f"runs:/{mlflow.active_run().info.run_id}/model"
            mlflow.register_model(model_uri, "trading_model")
    
    def load_best_model(self, model_name="trading_model"):
        client = mlflow.tracking.MlflowClient()
        latest = client.get_latest_versions(model_name, stages=["Production"])
        return mlflow.pytorch.load_model(latest[0].source)
```

### 8.2 ëª¨ë¸ ëª¨ë‹ˆí„°ë§ ë° ì¬í•™ìŠµ
```python
# src/mlops/monitoring.py
class ModelMonitor:
    def __init__(self, threshold=0.1):
        self.threshold = threshold
        self.baseline_metrics = None
    
    def detect_drift(self, current_metrics):
        if self.baseline_metrics is None:
            self.baseline_metrics = current_metrics
            return False
        drift = abs(current_metrics['sharpe'] - self.baseline_metrics['sharpe']) / self.baseline_metrics['sharpe']
        return drift > self.threshold
    
    def should_retrain(self, recent_performance):
        return self.detect_drift(recent_performance)

class AutoRetrainer:
    def __init__(self, mlops_manager, data_fetcher, model_class):
        self.mlops = mlops_manager
        self.data_fetcher = data_fetcher
        self.model_class = model_class
    
    def retrain(self, lookback_days=365):
        data = self.data_fetcher.get_historical_data(days=lookback_days)
        train, val = data[:int(len(data)*0.8)], data[int(len(data)*0.8):]
        
        model = self.model_class()
        self.mlops.train_and_log(model, model.get_params(), train, val)
```

---

## Part 9: ë©”ì¸ íŠ¸ë ˆì´ë”© ì‹œìŠ¤í…œ

### 9.1 í†µí•© ì‹œìŠ¤í…œ
```python
# src/core/trading_system.py
import asyncio

class TradingSystem:
    def __init__(self, config_path: str):
        # ì´ˆê¸°í™”
        self.broker = KISBroker(config_path, paper_trading=True)
        self.realtime = RealtimeDataHandler(self.broker)
        self.feature_store = FeatureStore()
        
        # ì „ëµ
        self.strategies = [
            MACrossoverStrategy(symbols=['005930', '000660'], fast_period=10, slow_period=30),
            RSIStrategy(symbols=['005930', '000660'], period=14),
            BollingerBandStrategy(symbols=['005930', '000660']),
        ]
        
        # ëª¨ë¸
        self.lstm_predictor = LSTMPredictor(window_size=20)
        self.regime_detector = RegimeDetector(n_states=2)
        
        # ë¦¬ìŠ¤í¬ ê´€ë¦¬
        self.risk_calc = RiskCalculator()
        self.position_sizer = PositionSizer()
        
        # ì•™ìƒë¸” ê°€ì¤‘ì¹˜
        self.ensemble_weights = {'MA_Crossover': 0.3, 'RSI': 0.2, 'Bollinger': 0.2, 'LSTM': 0.3}
    
    async def run(self):
        await self.realtime.connect()
        
        for symbol in ['005930', '000660']:
            await self.realtime.subscribe_price(symbol, self.on_price_update)
        
        while True:
            await asyncio.sleep(60)  # 1ë¶„ ë£¨í”„
            await self.trading_loop()
    
    async def on_price_update(self, data):
        self.feature_store.update(data['stock_code'], data)
    
    async def trading_loop(self):
        for symbol in ['005930', '000660']:
            data = self.feature_store.get_features(symbol)
            
            # ë ˆì§ ì²´í¬
            returns = data['close'].pct_change().dropna()
            regime = self.regime_detector.predict_regime(returns)
            if regime == 1:  # ê³ ë³€ë™ì„± ë ˆì§ - ì‹ ê·œ ì§„ì… ê¸ˆì§€
                continue
            
            # ì•™ìƒë¸” ì‹ í˜¸
            ensemble_signal = 0
            for strategy in self.strategies:
                signals = strategy.calculate_signals(data)
                for signal in signals:
                    if signal.symbol == symbol:
                        weight = self.ensemble_weights.get(strategy.name, 0.25)
                        ensemble_signal += weight * (1 if signal.signal_type == 'LONG' else -1) * signal.strength
            
            # LSTM ì˜ˆì¸¡
            pred_price = self.lstm_predictor.predict(data)
            current_price = data['close'].iloc[-1]
            lstm_signal = (pred_price - current_price) / current_price
            ensemble_signal += self.ensemble_weights['LSTM'] * np.sign(lstm_signal) * min(abs(lstm_signal), 1)
            
            # ë¦¬ìŠ¤í¬ ì²´í¬ ë° ì£¼ë¬¸
            if abs(ensemble_signal) > 0.5:
                portfolio_value = float(self.broker.get_balance()['output2'][0]['tot_evlu_amt'])
                var = self.risk_calc.historical_var(returns)
                
                if abs(var) < 0.05:  # VaR 5% ì´ë‚´
                    qty = self.position_sizer.volatility_sizing(
                        portfolio_value, 0.01, returns.std(), current_price)
                    direction = "BUY" if ensemble_signal > 0 else "SELL"
                    
                    if qty > 0:
                        result = self.broker.place_order(symbol, qty, direction)
                        print(f"Order: {symbol} {direction} {qty} - {result}")

# main.py
if __name__ == "__main__":
    system = TradingSystem("config/kis_config.yaml")
    asyncio.run(system.run())
```

---

## Part 10: ì„¤ì • íŒŒì¼ ì˜ˆì‹œ

### kis_config.yaml
```yaml
# Production
my_app: "YOUR_PRODUCTION_APPKEY"
my_sec: "YOUR_PRODUCTION_APPSECRET"

# Paper Trading
paper_app: "YOUR_PAPER_APPKEY"
paper_sec: "YOUR_PAPER_APPSECRET"

# Account
my_htsid: "YOUR_HTS_ID"
my_acct_stock: "12345678"
my_prod: "01"
```

### requirements.txt
```
torch>=2.0.0
numpy>=1.24.0
pandas>=2.0.0
scikit-learn>=1.2.0
statsmodels>=0.14.0
scipy>=1.10.0
hmmlearn>=0.3.0
pykalman>=0.9.5
optuna>=3.0.0
mlflow>=2.0.0
websockets>=11.0
pyyaml>=6.0
requests>=2.28.0
arch>=6.0.0
cvxpy>=1.3.0
pypfopt>=1.5.0
riskfolio-lib>=4.0.0
```

---

## êµ¬í˜„ ì²´í¬ë¦¬ìŠ¤íŠ¸

- [ ] í•œêµ­íˆ¬ìì¦ê¶Œ ê³„ì¢Œ ê°œì„¤ ë° API í‚¤ ë°œê¸‰
- [ ] ëª¨ì˜íˆ¬ì í™˜ê²½ì—ì„œ ì „ì²´ ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸
- [ ] ë°±í…ŒìŠ¤íŒ…ìœ¼ë¡œ ì „ëµ ê²€ì¦ (ìµœì†Œ 3ë…„ ë°ì´í„°)
- [ ] Walk-Forward Optimization ì‹¤í–‰
- [ ] VaR/CVaR ë¦¬ìŠ¤í¬ í•œë„ ì„¤ì •
- [ ] HMM ë ˆì§ ë””í…ì…˜ ëª¨ë¸ í•™ìŠµ
- [ ] LSTM/Transformer ëª¨ë¸ í•™ìŠµ ë° ê²€ì¦
- [ ] DQN ì—ì´ì „íŠ¸ í•™ìŠµ (ì‹œë®¬ë ˆì´ì…˜ í™˜ê²½)
- [ ] MLflow ëª¨ë¸ ë ˆì§€ìŠ¤íŠ¸ë¦¬ ì„¤ì •
- [ ] ì‹¤ì‹œê°„ WebSocket ì—°ê²° í…ŒìŠ¤íŠ¸
- [ ] ì‹¤ê±°ë˜ ì „í™˜ ì „ ìµœì†Œ 1ê°œì›” í˜ì´í¼ íŠ¸ë ˆì´ë”©

ì´ í”„ë¡¬í”„íŠ¸ëŠ” ë¸”ë¡œê·¸ ì½˜í…ì¸ ì—ì„œ ì¶”ì¶œí•œ ì•Œê³ ë¦¬ì¦˜, ì½”ë“œ íŒ¨í„´, êµ¬í˜„ ë°©ë²•ë¡ ì„ í†µí•©í•˜ì—¬ **ì—”ë“œíˆ¬ì—”ë“œ AI ìë™ë§¤ë§¤ ì‹œìŠ¤í…œ**ì„ êµ¬ì¶•í•  ìˆ˜ ìˆëŠ” ìƒì„¸í•œ ê°€ì´ë“œë¥¼ ì œê³µí•©ë‹ˆë‹¤.